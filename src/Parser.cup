import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean syntaxErrors = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

  public void syntax_error(Symbol current_token) {
    this.syntaxErrors = true;
    report_error("Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null);
  }

:};

terminal INTEGER, BOOLEAN, CHARACTER, RATIONAL, FLOAT, DICTIONARY, SEQUENCE, VOID, TOP;
terminal TRUE, FALSE;
terminal WHILE, IF, THEN, ELSE, ELSE_IF;
terminal LEN, IN, ALIAS, TYPEDEF, FINISH, DO, PRINT, READ, FORALL, FUNCTION_DEFINITION, OD, RETURN;
terminal STRING_LITERAL, CHAR_LITERAL;
terminal EQ, EQEQ, PLUS, MINUS, MULT, SLASH, CARET, UNDERSCORE, IDENTIFIER, COMMA, COLON, CONCATENATION, SEMI_COLON, NUMBER_LITERAL, PERIOD, MAIN;
terminal NEGATION, AND, OR;
terminal L_BRACKET, R_BRACKET, L_SQUARE_BRACKET, R_SQUARE_BRACKET, L_CURLY_BRACKET, R_CURLY_BRACKET, L_PAREN, R_PAREN;

nonterminal main_statements, statements, statement, program, td;
nonterminal main_function, global_space;
nonterminal datatype, primitivedatatype, aggregatedatatype;
nonterminal number, full_exp, dictlistobj, dictlistobj2, assignment, return_type, function, parameter_list, conditional, elseifs, elses, function_call;
nonterminal declist, declist2, declistobj;
nonterminal seqlistwithoutid, seqlist, seqlist2, seqlistobj;
nonterminal identifier_children, identifier_list;
nonterminal square_bracket_list, square_bracket_list_2, square_bracket_obj, square_bracket_obj_2;
nonterminal dictlist, dictlistwithoutid, dictlist2;
nonterminal constructor_list, constructor_list_2, constructor_list_obj;
nonterminal control_flow, forall, while;
nonterminal conditions, condition, conditional_operator, alllist, inlist;
nonterminal definelen, alias, print, read, truefalse;
nonterminal exp, unary_operator, binary_operator, integer_number, float_number, rational_number;
nonterminal concat_list, concat_list_obj;

precedence left PERIOD, IN, COLON, AND, OR, CONCATENATION;
precedence left CARET, SLASH, MULT, PLUS, MINUS;
precedence left L_PAREN, R_PAREN;

/* main has to be defined */
program ::= main_function
          | global_space main_function
          | main_function global_space
          | global_space main_function global_space
          ; 

/* anything outside the main function can only be an assignment or function */
global_space ::= global_space full_exp
               | full_exp
               ;

statements ::= statements:ss statement:s {:
                  Node n = (Node)ss;
                  n.addChild((Node)s);
                  RESULT = n;
               :}
             | /* empty */ {:
                  RESULT = new Node("Statements");
               :}
             ;

statement ::= full_exp:s {:
                RESULT = (Node)s;
              :}
            | control_flow
            | print SEMI_COLON
            | read SEMI_COLON
            | RETURN SEMI_COLON
            | RETURN exp SEMI_COLON
            | function_call SEMI_COLON
            ;

main_statements ::= statements:ss statement:s;

full_exp ::= assignment:a {: RESULT = new Node(a); :} SEMI_COLON
           | td:t {: RESULT = new Node(t); :} SEMI_COLON
           | function:f {: RESULT = new Node(f); :} SEMI_COLON
           | alias SEMI_COLON
           ;                         

main_function ::= MAIN L_CURLY_BRACKET main_statements:ss R_CURLY_BRACKET SEMI_COLON;

function ::= FUNCTION_DEFINITION:f return_type IDENTIFIER:i L_PAREN:lp parameter_list R_PAREN:rp L_CURLY_BRACKET:lc statements:ss R_CURLY_BRACKET:rc
           ;

/* parameter list for function */
parameter_list ::= declist
                 ;

number ::= rational_number
        |  float_number
        |  integer_number
        ;

exp ::= number
      | CHAR_LITERAL
      | STRING_LITERAL
      | identifier_children
      | exp binary_operator exp
      | L_PAREN exp R_PAREN
      | unary_operator exp
      | truefalse
      | definelen
      | function_call
      | exp IN inlist
      | exp IN L_PAREN inlist R_PAREN
      ;     

function_call ::= identifier_children L_PAREN constructor_list R_PAREN; //Allow functions inside expressions  e.g. foo(a, "12", 14);


alllist ::= seqlistwithoutid
          | dictlistwithoutid
          ;

inlist ::= concat_list
        ;

/* allow f.children.child2 */
identifier_children ::= IDENTIFIER identifier_list square_bracket_list;

identifier_list::= PERIOD IDENTIFIER identifier_list
                    | {: /* empty */ :}
                    ;

square_bracket_list ::= square_bracket_list_2
                      | {: /* empty */ :}
                      ;


square_bracket_list_2 ::= square_bracket_list_2 square_bracket_obj
                        | square_bracket_obj
                        ;

square_bracket_obj ::= L_SQUARE_BRACKET square_bracket_obj_2  R_SQUARE_BRACKET
                     ;

square_bracket_obj_2 ::= exp COLON exp //Sequence Splicing
                       | exp COLON
                       | COLON exp
                       | exp
                       ;

definelen ::= LEN L_PAREN exp R_PAREN;          

unary_operator ::= NEGATION {: RESULT = new Node("!"); :}; 

binary_operator ::= PLUS  {: RESULT = new Node("+"); :}
                 | MINUS {: RESULT = new Node("-"); :}
                 | MULT  {: RESULT = new Node("*"); :}
                 | SLASH  {: RESULT = new Node("/"); :}
                 | CARET  {: RESULT = new Node("^"); :}
                 | CONCATENATION {: RESULT = new Node("::"); :} 
                 ;

conditional_operator ::=  L_BRACKET
                      | R_BRACKET
                      | EQEQ
                      | L_BRACKET EQ
                      | R_BRACKET EQ
                      | unary_operator EQ
                      | AND
                      | OR
                      ;

integer_number ::= NUMBER_LITERAL:num
                 |  MINUS NUMBER_LITERAL:num
                 ;

float_number ::= NUMBER_LITERAL:num1 PERIOD NUMBER_LITERAL:num2
               | MINUS NUMBER_LITERAL:nu1 PERIOD NUMBER_LITERAL:num2
               ;

rational_number ::= integer_number SLASH integer_number
                  | integer_number UNDERSCORE integer_number SLASH integer_number
                  ;

datatype ::= primitivedatatype:p {: RESULT = new Node(p); :}
           | aggregatedatatype:a {: RESULT = new Node(a); :}
           | TOP:t {: RESULT = new Node("top"); :} //top can't be used in assign so it's put here
           ;

primitivedatatype ::= INTEGER:i {: RESULT = new Node("int"); :}
                    | BOOLEAN:b {: RESULT = new Node("bool"); :}
                    | RATIONAL:r {: RESULT = new Node("rat"); :}
                    | CHARACTER:c {: RESULT = new Node("char"); :}
                    | FLOAT:f {: RESULT = new Node("float"); :}
                    ;

/* valid return types for functions */
return_type ::= datatype
              | VOID {: RESULT = new Node("void"); :}
              ;

aggregatedatatype ::= DICTIONARY L_BRACKET primitivedatatype:p COMMA primitivedatatype:p2 R_BRACKET
                    | SEQUENCE L_BRACKET primitivedatatype:p R_BRACKET
                    | SEQUENCE L_BRACKET identifier_children R_BRACKET
                    | DICTIONARY L_BRACKET identifier_children COMMA primitivedatatype:p2 R_BRACKET
                    | DICTIONARY L_BRACKET primitivedatatype:p COMMA identifier_children R_BRACKET
                    | DICTIONARY L_BRACKET identifier_children COMMA identifier_children R_BRACKET
                    ;                 

assignment ::= primitivedatatype identifier_children:id EQ exp
             | identifier_children EQ exp
             | identifier_children EQ condition
             | identifier_children EQ identifier_children CONCATENATION concat_list
             | primitivedatatype identifier_children EQ identifier_children CONCATENATION concat_list
             | identifier_children identifier_children EQ condition
             | primitivedatatype identifier_children EQ condition
             | identifier_children identifier_children
             | primitivedatatype identifier_children 
             | SEQUENCE L_BRACKET datatype R_BRACKET identifier_children EQ STRING_LITERAL 
             | SEQUENCE L_BRACKET identifier_children R_BRACKET identifier_children EQ STRING_LITERAL
             | SEQUENCE L_BRACKET identifier_children R_BRACKET identifier_children EQ concat_list 
             | SEQUENCE L_BRACKET datatype R_BRACKET identifier_children EQ concat_list
             | DICTIONARY L_BRACKET datatype COMMA datatype R_BRACKET identifier_children EQ L_CURLY_BRACKET dictlist:dl R_CURLY_BRACKET
             | DICTIONARY L_BRACKET identifier_children COMMA identifier_children R_BRACKET identifier_children EQ L_CURLY_BRACKET dictlist:dl R_CURLY_BRACKET
             | DICTIONARY L_BRACKET datatype COMMA identifier_children R_BRACKET identifier_children EQ L_CURLY_BRACKET dictlist:dl R_CURLY_BRACKET
             | DICTIONARY L_BRACKET identifier_children COMMA datatype R_BRACKET identifier_children EQ L_CURLY_BRACKET dictlist:dl R_CURLY_BRACKET
             | identifier_children identifier_children EQ constructor_list //Allow new type assignment e.g. person d = "Shin", "Yoo", 30;
             ;


/* Constructor list for custom typedefs */

constructor_list ::= constructor_list_2
                   | {: /* empty */ :}
                   ;

constructor_list_2 ::= constructor_list_obj COMMA constructor_list_2
                   | constructor_list_obj
                   ;

constructor_list_obj ::= exp:e
                      | alllist
                      ;

concat_list ::= concat_list_obj CONCATENATION concat_list
               | concat_list_obj
               ;

concat_list_obj ::= function_call
                  | identifier_children
                  | seqlistwithoutid
                  ;

conditions ::= condition
            | condition OR conditions
            | condition AND conditions
            | identifier_children
            | unary_operator identifier_children
            | primitivedatatype
            | unary_operator primitivedatatype
            | truefalse
            | exp IN concat_list
            | exp IN L_PAREN concat_list R_PAREN
            ;

condition ::= exp conditional_operator exp
            ;

truefalse ::= TRUE
            | FALSE
            ;

declist ::= declist2:dl2
          | {: /* empty */ :}     
          ;

declist2 ::= declistobj:dlo COMMA:c declist2:dl {: 
                  Node n = new Node(dl);
                  n.addChild(new Node(dlo));
                  RESULT = n; :}
          | declistobj:dlo {: RESULT = new Node(dlo); :}        
          ;

declistobj ::= primitivedatatype:p identifier_children:i {:
                  RESULT = (Node)p; 
               :}
             | aggregatedatatype:a identifier_children:i {:
                  RESULT = (Node)a;
               :}
             | identifier_children identifier_children
             ;

seqlist ::= seqlist2:sl2
          | {: /* empty */ :}
          ;

seqlist2 ::= seqlistobj:slo COMMA:c seqlist2:sl {:
                  Node n = new Node(sl);
                  n.addChild(new Node(slo));
                  RESULT = n; :}
           | seqlistobj:slo {: RESULT = new Node(slo); :}
           ;      

seqlistwithoutid ::= L_SQUARE_BRACKET seqlist:sl R_SQUARE_BRACKET
                  |  L_PAREN L_SQUARE_BRACKET seqlist:sl R_SQUARE_BRACKET R_PAREN
                  ; 

seqlistobj ::= exp:e
             | seqlistwithoutid:sl
             | dictlistwithoutid:dl
             ; 

dictlist ::= dictlist2:dl2
           | {: /* empty */ :}
           ;

dictlist2 ::= dictlistobj:dlo COMMA:c dictlist2:dl {:
                  Node n = new Node(dl);
                  n.addChild(new Node(dlo));
                  RESULT = n; :}
            | dictlistobj:dlo {: RESULT = new Node(dlo); :}
            ; 

dictlistobj ::= dictlistobj2 COLON:c dictlistobj2 
;

dictlistobj2 ::= exp
              | dictlistwithoutid
              | seqlistwithoutid
              ;

dictlistwithoutid ::= L_CURLY_BRACKET dictlist:dl R_CURLY_BRACKET
                    | L_PAREN L_CURLY_BRACKET dictlist:dl R_CURLY_BRACKET R_PAREN
                    ;

td ::= TYPEDEF:t identifier_children:i L_CURLY_BRACKET:l declist:dl R_CURLY_BRACKET:r {:
                  RESULT = new Node(t);
:};

/* collection of control flow e.g. if and forall */
control_flow ::= forall
               | conditional
               | while
               ;

forall ::= FORALL L_PAREN identifier_children IN identifier_children R_PAREN DO statements:ss OD
         ;
         
/* IF statement, 0 or more else ifs, 0 or 1 else, FI */
conditional ::= IF L_PAREN conditions R_PAREN THEN statements:ss2 elseifs:eif elses FINISH 
;            

elseifs ::= ELSE_IF L_PAREN conditions R_PAREN THEN statements:ss elseifs:e
          | /* empty */ 
          ;

elses ::= ELSE statements
        | /* empty */
        ;        

while ::= WHILE L_PAREN conditions R_PAREN DO statements OD;

alias ::= ALIAS datatype identifier_children
        | ALIAS identifier_children identifier_children
        ;

read ::= READ identifier_children;

print ::= PRINT exp;