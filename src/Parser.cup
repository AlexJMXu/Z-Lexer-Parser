import java_cup.runtime.*;
import java.util.ArrayList;

/*
TODO Do we have to check for undefined variables?
TODO Do we have to check if types are compatible?
*/

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};

terminal INTEGER, BOOLEAN, CHARACTER, RATIONAL, FLOAT, DICTIONARY, SEQUENCE, VOID, TOP;
terminal TRUE, FALSE;
terminal IN, ALIAS, TYPEDEF, WHILE, IF, THEN, ELSE, ELSE_IF, FINISH, DO, PRINT, READ, FORALL, FUNCTION_DEFINITION, OD, RETURN;
terminal EQ, EQEQ, PLUS, MINUS, MULT, SLASH, CARET, UNDERSCORE, IDENTIFIER, L_BRACKET, R_BRACKET, L_SQUARE_BRACKET, R_SQUARE_BRACKET, COMMA, COLON, SEMI_COLON, L_CURLY_BRACKET, R_CURLY_BRACKET, L_PAREN, R_PAREN, NUMBER_LITERAL, NEGATION, AND, OR, STRING_LITERAL, CHAR_LITERAL, PERIOD, MAIN;

nonterminal statements, statement, program, td;
nonterminal main_function, global_space;
nonterminal datatype, primitivedatatype, aggregatedatatype;
nonterminal number, full_exp, declist, declist2, declistobj, operator, assignment, return_type, function, parameter_list, conditional, elseifs;
nonterminal control_flow, forall;
nonterminal integer_number, float_number, rational_number;
nonterminal conditions, condition, exp;

precedence left PLUS, MINUS;
precedence left SLASH, MULT;

/* main has to be defined */
program ::= main_function
          | global_space main_function
          | main_function global_space
          | global_space main_function global_space
          ; 

/* anything outside the main function can only be an assignment or function */
global_space ::= global_space full_exp
               | full_exp
               ;

statements ::= statements:ss statement:s {:
                  Node n = (Node)ss;
                  n.addChild((Node)s);
                  RESULT = n;
               :}
             | /* empty */ {:
                  RESULT = new Node("Statements");
               :}
             ;

statement ::= full_exp:s {:
                RESULT = (Node)s;
              :}
            | control_flow
            ;

full_exp ::= assignment:a {: RESULT = new Node(a); :} SEMI_COLON
           | td:t {: RESULT = new Node(t); :} SEMI_COLON
           | function:f {: RESULT = new Node(f); :} SEMI_COLON
           ;   

conditional ::= IF L_PAREN conditions R_PAREN THEN statements:ss FINISH 
              | IF L_PAREN conditions R_PAREN THEN statements:ss2 ELSE statements:ss3 FINISH 
              | IF L_PAREN conditions R_PAREN THEN statements:ss4 elseifs:eif FINISH
              ;                
              
elseifs ::= ELSE_IF statements:ss elseifs;               

main_function ::= MAIN L_CURLY_BRACKET statements:ss R_CURLY_BRACKET;

function ::= FUNCTION_DEFINITION:f return_type IDENTIFIER:i L_PAREN:lp parameter_list R_PAREN:rp L_CURLY_BRACKET:lc statements:ss R_CURLY_BRACKET:rc
           ;

/* parameter list for function */
parameter_list ::= declist
                 ;

number ::= rational_number
        |  float_number
        |  integer_number
        ;

integer_number ::= NUMBER_LITERAL:num
        |  MINUS NUMBER_LITERAL:num
        |  L_PAREN NUMBER_LITERAL:num R_PAREN
        |  L_PAREN MINUS NUMBER_LITERAL:num R_PAREN
        ;

float_number ::= NUMBER_LITERAL:num1 PERIOD NUMBER_LITERAL:num2
              |  MINUS NUMBER_LITERAL:nu1 PERIOD NUMBER_LITERAL:num2
              |  L_PAREN NUMBER_LITERAL:num1 PERIOD NUMBER_LITERAL:num2 R_PAREN
              |  L_PAREN MINUS NUMBER_LITERAL:num1 PERIOD NUMBER_LITERAL:num2 R_PAREN
              ;

rational_number ::= integer_number SLASH integer_number
                 |  integer_number UNDERSCORE integer_number SLASH integer_number
                 |  L_PAREN integer_number SLASH integer_number R_PAREN
                 |  L_PAREN integer_number UNDERSCORE integer_number SLASH integer_number R_PAREN
                 ;

/* TODO Add tdef types to datatype */

datatype ::= primitivedatatype:p {: RESULT = new Node(p); :}
           | aggregatedatatype:a {: RESULT = new Node(a); :}
           ;

primitivedatatype ::= INTEGER:i {: RESULT = new Node("int"); :}
                    | BOOLEAN:b {: RESULT = new Node("bool"); :}
                    | RATIONAL:r {: RESULT = new Node("rat"); :}
                    | CHARACTER:c {: RESULT = new Node("char"); :}
                    | FLOAT:f {: RESULT = new Node("float"); :}
                    ;

/* valid return types for functions */
return_type ::= datatype
              | VOID {: RESULT = new Node("void"); :}
              ;

aggregatedatatype ::= DICTIONARY L_BRACKET primitivedatatype:p COMMA primitivedatatype:p2 R_BRACKET
                    | SEQUENCE L_BRACKET primitivedatatype:p R_BRACKET
                ;

/* TODO Fix assignment e.g. int n = 5 + 6; */
/* datatype to identifier
assignment ::= :dt IDENTIFIER:id EQ number
            |  primitivedatatype IDENTIFIER:id EQ exp
            |  SEQUENCE L_BRACKET primitivedatatype:p R_BRACKET IDENTIFIER:id EQ L_SQUARE_BRACKET  R_SQUARE_BRACKET
            |  DICTIONARY L_BRACKET primitivedatatype:p COMMA primitivedatatype:p2 R_BRACKET IDENTIFIER:id EQ L_CURLY_BRACKET R_CURLY_BRACKET
            ;

/* TODO add the conditions */
conditions ::= condition
            | condition OR conditions
            | condition AND conditions
            ;

condition ::= exp L_BRACKET exp
            | exp R_BRACKET exp
            | exp EQEQ exp
            | exp L_BRACKET EQ exp
            | exp R_BRACKET EQ exp
            | exp NEGATION EQ exp
            | exp
            ;

/* TO-DO find a way to get functions name from fdef */

declist ::= declist2:dl2
          | {: /* empty */ :}     
          ;

declist2 ::= declistobj:dlo COMMA:c declist2:dl {: 
                  Node n = new Node(dl);
                  n.addChild(new Node(dlo));
                  RESULT = n; :}
          | declistobj:dlo {: RESULT = new Node(dlo); :}        
          ;        

declistobj ::= datatype:d IDENTIFIER:i {:
                  RESULT = (Node)d; 
               :}
             ;


td ::= TYPEDEF:t IDENTIFIER:i L_CURLY_BRACKET:l declist:dl R_CURLY_BRACKET:r {: 
                  RESULT = new Node(t);
:};

operator ::= PLUS  {: RESULT = new Node("+"); :}
           | MINUS {: RESULT = new Node("-"); :}
           | MULT  {: RESULT = new Node("*"); :}
           | SLASH  {: RESULT = new Node("/"); :}
           ;

/* collection of control flow e.g. if and forall */
control_flow ::= forall
               ;
forall ::= FORALL L_PAREN IDENTIFIER IN IDENTIFIER R_PAREN DO statements:ss OD
         ;