import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};

parser code {:

  private boolean debug = false;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}

  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;

    public int counter;
    private Object value;

    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }

    public void addChild(Node n){ children.add(n); }

    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }

  private Lexer lexer;

  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }

:};

terminal INTEGER, BOOLEAN, CHARACTER, RATIONAL, FLOAT, DICTIONARY, SEQUENCE, VOID, TOP, TRUE, FALSE, IN, ALIAS, TYPEDEF, WHILE, IF, THEN, ELSE, ELSE_IF, FINISH, DO, PRINT, READ, FORALL, FUNCTION_DEFINITION, OD, RETURN, EQ, EQEQ, PLUS, MINUS, MULT, SLASH, CARET, UNDERSCORE, IDENTIFIER, L_BRACKET, R_BRACKET, L_SQUARE_BRACKET, R_SQUARE_BRACKET, COMMA, COLON, SEMI_COLON, L_CURLY_BRACKET, R_CURLY_BRACKET, L_PAREN, R_PAREN, NUMBER_LITERAL, NEGATION, AND, OR, STRING_LITERAL, CHAR_LITERAL;

nonterminal statements, statement, top_level;
nonterminal full_exp, operator;
nonterminal number, assignment, datatype, primitivedatatype, aggregatedatatype;

precedence left PLUS, MINUS;
precedence left SLASH, MULT;

top_level ::= statements:ss {:
                if(debug()) System.out.println((Node)ss);
              :}
            ;

datatype ::= primitivedatatype:p {: RESULT = (Node)p; :}
           | aggregatedatatype:a {: RESULT = (Node)a; :}
           ;

assignment ::= datatype:dt IDENTIFIER:id EQ number:num {:
                  Node n = (Node)dt;
                  n.addChild(new Node(id));
                  n.addChild(new Node("="));
                  n.addChild((Node)num);
                  RESULT = n;
              :}
              ;

number ::= NUMBER_LITERAL:num {: RESULT = new Node(num); :}
        |  MINUS NUMBER_LITERAL:num {:
            Node n = new Node("-");
            n.addChild(new Node(num));
            RESULT = n;
        :}
        ;

primitivedatatype ::= INTEGER:i {: RESULT = new Node("int"); :}
                    | BOOLEAN:b {: RESULT = new Node("bool"); :}
                    | RATIONAL:r {: RESULT = new Node("rat"); :}
                    | CHARACTER:c {: RESULT = new Node("char"); :}
                    | FLOAT:f {: RESULT = new Node("float"); :}
                    ;

aggregatedatatype ::= DICTIONARY L_BRACKET primitivedatatype:p COMMA primitivedatatype:p2 R_BRACKET {: 
                        Node n = new Node("dict");
                        n.addChild(new Node("<"));
                        n.addChild((Node)(p));
                        n.addChild(new Node(","));
                        n.addChild((Node)(p2));
                        n.addChild(new Node(">"));
                        RESULT = n; 
                    :}
                    | SEQUENCE L_BRACKET primitivedatatype:p R_BRACKET {:
                        Node n = new Node("seq");
                        n.addChild(new Node("<"));
                        n.addChild((Node)(p));
                        n.addChild(new Node(">"));
                        RESULT = n;
                    :}
                ;

statements ::= statements:ss statement:s {:
                  Node n = (Node)ss;
                  n.addChild((Node)s);
                  RESULT = n;
               :}
             | /* empty */ {:
                  RESULT = new Node("Statements");
               :}
             ;

statement ::= full_exp:s {:
                RESULT = (Node)s;
              :}
            ;

full_exp ::= assignment:a {: RESULT = (Node)a; :}
           SEMI_COLON;

operator ::= PLUS  {: RESULT = new Node("+"); :}
           | MINUS {: RESULT = new Node("-"); :}
           | MULT  {: RESULT = new Node("*"); :}
           | SLASH  {: RESULT = new Node("/"); :}
           ;